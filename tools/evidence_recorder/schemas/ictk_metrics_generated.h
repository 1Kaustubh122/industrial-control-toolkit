// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ICTKMETRICS_ICTK_METRICS_H_
#define FLATBUFFERS_GENERATED_ICTKMETRICS_ICTK_METRICS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 8,
             "Non-compatible flatbuffers version included");

namespace ictk {
namespace metrics {

struct BuildInfo;
struct BuildInfoBuilder;

struct Tick;
struct TickBuilder;

struct Health;
struct HealthBuilder;

struct Kpi;
struct KpiBuilder;

struct TimeAnchor;
struct TimeAnchorBuilder;

enum Mode : uint8_t {
  Mode_Primary = 0,
  Mode_Residual = 1,
  Mode_Shadow = 2,
  Mode_Cooperative = 3,
  Mode_MIN = Mode_Primary,
  Mode_MAX = Mode_Cooperative
};

inline const Mode (&EnumValuesMode())[4] {
  static const Mode values[] = {
    Mode_Primary,
    Mode_Residual,
    Mode_Shadow,
    Mode_Cooperative
  };
  return values;
}

inline const char * const *EnumNamesMode() {
  static const char * const names[5] = {
    "Primary",
    "Residual",
    "Shadow",
    "Cooperative",
    nullptr
  };
  return names;
}

inline const char *EnumNameMode(Mode e) {
  if (flatbuffers::IsOutRange(e, Mode_Primary, Mode_Cooperative)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMode()[index];
}

struct BuildInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BuildInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ICTK_VERSION = 4,
    VT_GIT_SHA = 6,
    VT_COMPILER = 8,
    VT_FLAGS = 10,
    VT_SCALAR_TYPE = 12,
    VT_DT_NS = 14,
    VT_CONTROLLER_ID = 16,
    VT_ASSET_ID = 18,
    VT_TICK_DECIMATION = 20
  };
  const flatbuffers::String *ictk_version() const {
    return GetPointer<const flatbuffers::String *>(VT_ICTK_VERSION);
  }
  const flatbuffers::String *git_sha() const {
    return GetPointer<const flatbuffers::String *>(VT_GIT_SHA);
  }
  const flatbuffers::String *compiler() const {
    return GetPointer<const flatbuffers::String *>(VT_COMPILER);
  }
  const flatbuffers::String *flags() const {
    return GetPointer<const flatbuffers::String *>(VT_FLAGS);
  }
  const flatbuffers::String *scalar_type() const {
    return GetPointer<const flatbuffers::String *>(VT_SCALAR_TYPE);
  }
  uint64_t dt_ns() const {
    return GetField<uint64_t>(VT_DT_NS, 0);
  }
  const flatbuffers::String *controller_id() const {
    return GetPointer<const flatbuffers::String *>(VT_CONTROLLER_ID);
  }
  const flatbuffers::String *asset_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ASSET_ID);
  }
  uint32_t tick_decimation() const {
    return GetField<uint32_t>(VT_TICK_DECIMATION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ICTK_VERSION) &&
           verifier.VerifyString(ictk_version()) &&
           VerifyOffset(verifier, VT_GIT_SHA) &&
           verifier.VerifyString(git_sha()) &&
           VerifyOffset(verifier, VT_COMPILER) &&
           verifier.VerifyString(compiler()) &&
           VerifyOffset(verifier, VT_FLAGS) &&
           verifier.VerifyString(flags()) &&
           VerifyOffset(verifier, VT_SCALAR_TYPE) &&
           verifier.VerifyString(scalar_type()) &&
           VerifyField<uint64_t>(verifier, VT_DT_NS, 8) &&
           VerifyOffset(verifier, VT_CONTROLLER_ID) &&
           verifier.VerifyString(controller_id()) &&
           VerifyOffset(verifier, VT_ASSET_ID) &&
           verifier.VerifyString(asset_id()) &&
           VerifyField<uint32_t>(verifier, VT_TICK_DECIMATION, 4) &&
           verifier.EndTable();
  }
};

struct BuildInfoBuilder {
  typedef BuildInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ictk_version(flatbuffers::Offset<flatbuffers::String> ictk_version) {
    fbb_.AddOffset(BuildInfo::VT_ICTK_VERSION, ictk_version);
  }
  void add_git_sha(flatbuffers::Offset<flatbuffers::String> git_sha) {
    fbb_.AddOffset(BuildInfo::VT_GIT_SHA, git_sha);
  }
  void add_compiler(flatbuffers::Offset<flatbuffers::String> compiler) {
    fbb_.AddOffset(BuildInfo::VT_COMPILER, compiler);
  }
  void add_flags(flatbuffers::Offset<flatbuffers::String> flags) {
    fbb_.AddOffset(BuildInfo::VT_FLAGS, flags);
  }
  void add_scalar_type(flatbuffers::Offset<flatbuffers::String> scalar_type) {
    fbb_.AddOffset(BuildInfo::VT_SCALAR_TYPE, scalar_type);
  }
  void add_dt_ns(uint64_t dt_ns) {
    fbb_.AddElement<uint64_t>(BuildInfo::VT_DT_NS, dt_ns, 0);
  }
  void add_controller_id(flatbuffers::Offset<flatbuffers::String> controller_id) {
    fbb_.AddOffset(BuildInfo::VT_CONTROLLER_ID, controller_id);
  }
  void add_asset_id(flatbuffers::Offset<flatbuffers::String> asset_id) {
    fbb_.AddOffset(BuildInfo::VT_ASSET_ID, asset_id);
  }
  void add_tick_decimation(uint32_t tick_decimation) {
    fbb_.AddElement<uint32_t>(BuildInfo::VT_TICK_DECIMATION, tick_decimation, 0);
  }
  explicit BuildInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BuildInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BuildInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<BuildInfo> CreateBuildInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> ictk_version = 0,
    flatbuffers::Offset<flatbuffers::String> git_sha = 0,
    flatbuffers::Offset<flatbuffers::String> compiler = 0,
    flatbuffers::Offset<flatbuffers::String> flags = 0,
    flatbuffers::Offset<flatbuffers::String> scalar_type = 0,
    uint64_t dt_ns = 0,
    flatbuffers::Offset<flatbuffers::String> controller_id = 0,
    flatbuffers::Offset<flatbuffers::String> asset_id = 0,
    uint32_t tick_decimation = 0) {
  BuildInfoBuilder builder_(_fbb);
  builder_.add_dt_ns(dt_ns);
  builder_.add_tick_decimation(tick_decimation);
  builder_.add_asset_id(asset_id);
  builder_.add_controller_id(controller_id);
  builder_.add_scalar_type(scalar_type);
  builder_.add_flags(flags);
  builder_.add_compiler(compiler);
  builder_.add_git_sha(git_sha);
  builder_.add_ictk_version(ictk_version);
  return builder_.Finish();
}

inline flatbuffers::Offset<BuildInfo> CreateBuildInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *ictk_version = nullptr,
    const char *git_sha = nullptr,
    const char *compiler = nullptr,
    const char *flags = nullptr,
    const char *scalar_type = nullptr,
    uint64_t dt_ns = 0,
    const char *controller_id = nullptr,
    const char *asset_id = nullptr,
    uint32_t tick_decimation = 0) {
  auto ictk_version__ = ictk_version ? _fbb.CreateString(ictk_version) : 0;
  auto git_sha__ = git_sha ? _fbb.CreateString(git_sha) : 0;
  auto compiler__ = compiler ? _fbb.CreateString(compiler) : 0;
  auto flags__ = flags ? _fbb.CreateString(flags) : 0;
  auto scalar_type__ = scalar_type ? _fbb.CreateString(scalar_type) : 0;
  auto controller_id__ = controller_id ? _fbb.CreateString(controller_id) : 0;
  auto asset_id__ = asset_id ? _fbb.CreateString(asset_id) : 0;
  return ictk::metrics::CreateBuildInfo(
      _fbb,
      ictk_version__,
      git_sha__,
      compiler__,
      flags__,
      scalar_type__,
      dt_ns,
      controller_id__,
      asset_id__,
      tick_decimation);
}

struct Tick FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TickBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEQ = 4,
    VT_T_NS = 6,
    VT_Y0 = 8,
    VT_R0 = 10,
    VT_U_PRE0 = 12,
    VT_U_POST0 = 14
  };
  uint64_t seq() const {
    return GetField<uint64_t>(VT_SEQ, 0);
  }
  uint64_t t_ns() const {
    return GetField<uint64_t>(VT_T_NS, 0);
  }
  double y0() const {
    return GetField<double>(VT_Y0, 0.0);
  }
  double r0() const {
    return GetField<double>(VT_R0, 0.0);
  }
  double u_pre0() const {
    return GetField<double>(VT_U_PRE0, 0.0);
  }
  double u_post0() const {
    return GetField<double>(VT_U_POST0, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_SEQ, 8) &&
           VerifyField<uint64_t>(verifier, VT_T_NS, 8) &&
           VerifyField<double>(verifier, VT_Y0, 8) &&
           VerifyField<double>(verifier, VT_R0, 8) &&
           VerifyField<double>(verifier, VT_U_PRE0, 8) &&
           VerifyField<double>(verifier, VT_U_POST0, 8) &&
           verifier.EndTable();
  }
};

struct TickBuilder {
  typedef Tick Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_seq(uint64_t seq) {
    fbb_.AddElement<uint64_t>(Tick::VT_SEQ, seq, 0);
  }
  void add_t_ns(uint64_t t_ns) {
    fbb_.AddElement<uint64_t>(Tick::VT_T_NS, t_ns, 0);
  }
  void add_y0(double y0) {
    fbb_.AddElement<double>(Tick::VT_Y0, y0, 0.0);
  }
  void add_r0(double r0) {
    fbb_.AddElement<double>(Tick::VT_R0, r0, 0.0);
  }
  void add_u_pre0(double u_pre0) {
    fbb_.AddElement<double>(Tick::VT_U_PRE0, u_pre0, 0.0);
  }
  void add_u_post0(double u_post0) {
    fbb_.AddElement<double>(Tick::VT_U_POST0, u_post0, 0.0);
  }
  explicit TickBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Tick> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tick>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tick> CreateTick(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t seq = 0,
    uint64_t t_ns = 0,
    double y0 = 0.0,
    double r0 = 0.0,
    double u_pre0 = 0.0,
    double u_post0 = 0.0) {
  TickBuilder builder_(_fbb);
  builder_.add_u_post0(u_post0);
  builder_.add_u_pre0(u_pre0);
  builder_.add_r0(r0);
  builder_.add_y0(y0);
  builder_.add_t_ns(t_ns);
  builder_.add_seq(seq);
  return builder_.Finish();
}

struct Health FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HealthBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEADLINE_MISS_COUNT = 4,
    VT_SATURATION_PCT = 6,
    VT_RATE_HITS = 8,
    VT_JERK_HITS = 10,
    VT_FALLBACK_ACTIVE = 12,
    VT_NOVELTY_FLAG = 14,
    VT_AW_TERM_MAG = 16,
    VT_LAST_CLAMP_MAG = 18,
    VT_LAST_RATE_CLIP_MAG = 20,
    VT_LAST_JERK_CLIP_MAG = 22,
    VT_MODE = 24
  };
  uint64_t deadline_miss_count() const {
    return GetField<uint64_t>(VT_DEADLINE_MISS_COUNT, 0);
  }
  double saturation_pct() const {
    return GetField<double>(VT_SATURATION_PCT, 0.0);
  }
  uint64_t rate_hits() const {
    return GetField<uint64_t>(VT_RATE_HITS, 0);
  }
  uint64_t jerk_hits() const {
    return GetField<uint64_t>(VT_JERK_HITS, 0);
  }
  bool fallback_active() const {
    return GetField<uint8_t>(VT_FALLBACK_ACTIVE, 0) != 0;
  }
  bool novelty_flag() const {
    return GetField<uint8_t>(VT_NOVELTY_FLAG, 0) != 0;
  }
  double aw_term_mag() const {
    return GetField<double>(VT_AW_TERM_MAG, 0.0);
  }
  double last_clamp_mag() const {
    return GetField<double>(VT_LAST_CLAMP_MAG, 0.0);
  }
  double last_rate_clip_mag() const {
    return GetField<double>(VT_LAST_RATE_CLIP_MAG, 0.0);
  }
  double last_jerk_clip_mag() const {
    return GetField<double>(VT_LAST_JERK_CLIP_MAG, 0.0);
  }
  ictk::metrics::Mode mode() const {
    return static_cast<ictk::metrics::Mode>(GetField<uint8_t>(VT_MODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_DEADLINE_MISS_COUNT, 8) &&
           VerifyField<double>(verifier, VT_SATURATION_PCT, 8) &&
           VerifyField<uint64_t>(verifier, VT_RATE_HITS, 8) &&
           VerifyField<uint64_t>(verifier, VT_JERK_HITS, 8) &&
           VerifyField<uint8_t>(verifier, VT_FALLBACK_ACTIVE, 1) &&
           VerifyField<uint8_t>(verifier, VT_NOVELTY_FLAG, 1) &&
           VerifyField<double>(verifier, VT_AW_TERM_MAG, 8) &&
           VerifyField<double>(verifier, VT_LAST_CLAMP_MAG, 8) &&
           VerifyField<double>(verifier, VT_LAST_RATE_CLIP_MAG, 8) &&
           VerifyField<double>(verifier, VT_LAST_JERK_CLIP_MAG, 8) &&
           VerifyField<uint8_t>(verifier, VT_MODE, 1) &&
           verifier.EndTable();
  }
};

struct HealthBuilder {
  typedef Health Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_deadline_miss_count(uint64_t deadline_miss_count) {
    fbb_.AddElement<uint64_t>(Health::VT_DEADLINE_MISS_COUNT, deadline_miss_count, 0);
  }
  void add_saturation_pct(double saturation_pct) {
    fbb_.AddElement<double>(Health::VT_SATURATION_PCT, saturation_pct, 0.0);
  }
  void add_rate_hits(uint64_t rate_hits) {
    fbb_.AddElement<uint64_t>(Health::VT_RATE_HITS, rate_hits, 0);
  }
  void add_jerk_hits(uint64_t jerk_hits) {
    fbb_.AddElement<uint64_t>(Health::VT_JERK_HITS, jerk_hits, 0);
  }
  void add_fallback_active(bool fallback_active) {
    fbb_.AddElement<uint8_t>(Health::VT_FALLBACK_ACTIVE, static_cast<uint8_t>(fallback_active), 0);
  }
  void add_novelty_flag(bool novelty_flag) {
    fbb_.AddElement<uint8_t>(Health::VT_NOVELTY_FLAG, static_cast<uint8_t>(novelty_flag), 0);
  }
  void add_aw_term_mag(double aw_term_mag) {
    fbb_.AddElement<double>(Health::VT_AW_TERM_MAG, aw_term_mag, 0.0);
  }
  void add_last_clamp_mag(double last_clamp_mag) {
    fbb_.AddElement<double>(Health::VT_LAST_CLAMP_MAG, last_clamp_mag, 0.0);
  }
  void add_last_rate_clip_mag(double last_rate_clip_mag) {
    fbb_.AddElement<double>(Health::VT_LAST_RATE_CLIP_MAG, last_rate_clip_mag, 0.0);
  }
  void add_last_jerk_clip_mag(double last_jerk_clip_mag) {
    fbb_.AddElement<double>(Health::VT_LAST_JERK_CLIP_MAG, last_jerk_clip_mag, 0.0);
  }
  void add_mode(ictk::metrics::Mode mode) {
    fbb_.AddElement<uint8_t>(Health::VT_MODE, static_cast<uint8_t>(mode), 0);
  }
  explicit HealthBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Health> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Health>(end);
    return o;
  }
};

inline flatbuffers::Offset<Health> CreateHealth(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t deadline_miss_count = 0,
    double saturation_pct = 0.0,
    uint64_t rate_hits = 0,
    uint64_t jerk_hits = 0,
    bool fallback_active = false,
    bool novelty_flag = false,
    double aw_term_mag = 0.0,
    double last_clamp_mag = 0.0,
    double last_rate_clip_mag = 0.0,
    double last_jerk_clip_mag = 0.0,
    ictk::metrics::Mode mode = ictk::metrics::Mode_Primary) {
  HealthBuilder builder_(_fbb);
  builder_.add_last_jerk_clip_mag(last_jerk_clip_mag);
  builder_.add_last_rate_clip_mag(last_rate_clip_mag);
  builder_.add_last_clamp_mag(last_clamp_mag);
  builder_.add_aw_term_mag(aw_term_mag);
  builder_.add_jerk_hits(jerk_hits);
  builder_.add_rate_hits(rate_hits);
  builder_.add_saturation_pct(saturation_pct);
  builder_.add_deadline_miss_count(deadline_miss_count);
  builder_.add_mode(mode);
  builder_.add_novelty_flag(novelty_flag);
  builder_.add_fallback_active(fallback_active);
  return builder_.Finish();
}

struct Kpi FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef KpiBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UPDATES = 4,
    VT_WATCHDOG_TRIPS = 6,
    VT_FALLBACK_ENTRIES = 8,
    VT_LIMIT_HITS = 10,
    VT_IAE = 12,
    VT_ITAE = 14,
    VT_TVU = 16,
    VT_P50_LAT_US = 18,
    VT_P95_LAT_US = 20,
    VT_P99_LAT_US = 22,
    VT_HEALTH_GAP_FRAMES = 24
  };
  uint64_t updates() const {
    return GetField<uint64_t>(VT_UPDATES, 0);
  }
  uint64_t watchdog_trips() const {
    return GetField<uint64_t>(VT_WATCHDOG_TRIPS, 0);
  }
  uint64_t fallback_entries() const {
    return GetField<uint64_t>(VT_FALLBACK_ENTRIES, 0);
  }
  uint64_t limit_hits() const {
    return GetField<uint64_t>(VT_LIMIT_HITS, 0);
  }
  double iae() const {
    return GetField<double>(VT_IAE, 0.0);
  }
  double itae() const {
    return GetField<double>(VT_ITAE, 0.0);
  }
  double tvu() const {
    return GetField<double>(VT_TVU, 0.0);
  }
  double p50_lat_us() const {
    return GetField<double>(VT_P50_LAT_US, 0.0);
  }
  double p95_lat_us() const {
    return GetField<double>(VT_P95_LAT_US, 0.0);
  }
  double p99_lat_us() const {
    return GetField<double>(VT_P99_LAT_US, 0.0);
  }
  uint64_t health_gap_frames() const {
    return GetField<uint64_t>(VT_HEALTH_GAP_FRAMES, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_UPDATES, 8) &&
           VerifyField<uint64_t>(verifier, VT_WATCHDOG_TRIPS, 8) &&
           VerifyField<uint64_t>(verifier, VT_FALLBACK_ENTRIES, 8) &&
           VerifyField<uint64_t>(verifier, VT_LIMIT_HITS, 8) &&
           VerifyField<double>(verifier, VT_IAE, 8) &&
           VerifyField<double>(verifier, VT_ITAE, 8) &&
           VerifyField<double>(verifier, VT_TVU, 8) &&
           VerifyField<double>(verifier, VT_P50_LAT_US, 8) &&
           VerifyField<double>(verifier, VT_P95_LAT_US, 8) &&
           VerifyField<double>(verifier, VT_P99_LAT_US, 8) &&
           VerifyField<uint64_t>(verifier, VT_HEALTH_GAP_FRAMES, 8) &&
           verifier.EndTable();
  }
};

struct KpiBuilder {
  typedef Kpi Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_updates(uint64_t updates) {
    fbb_.AddElement<uint64_t>(Kpi::VT_UPDATES, updates, 0);
  }
  void add_watchdog_trips(uint64_t watchdog_trips) {
    fbb_.AddElement<uint64_t>(Kpi::VT_WATCHDOG_TRIPS, watchdog_trips, 0);
  }
  void add_fallback_entries(uint64_t fallback_entries) {
    fbb_.AddElement<uint64_t>(Kpi::VT_FALLBACK_ENTRIES, fallback_entries, 0);
  }
  void add_limit_hits(uint64_t limit_hits) {
    fbb_.AddElement<uint64_t>(Kpi::VT_LIMIT_HITS, limit_hits, 0);
  }
  void add_iae(double iae) {
    fbb_.AddElement<double>(Kpi::VT_IAE, iae, 0.0);
  }
  void add_itae(double itae) {
    fbb_.AddElement<double>(Kpi::VT_ITAE, itae, 0.0);
  }
  void add_tvu(double tvu) {
    fbb_.AddElement<double>(Kpi::VT_TVU, tvu, 0.0);
  }
  void add_p50_lat_us(double p50_lat_us) {
    fbb_.AddElement<double>(Kpi::VT_P50_LAT_US, p50_lat_us, 0.0);
  }
  void add_p95_lat_us(double p95_lat_us) {
    fbb_.AddElement<double>(Kpi::VT_P95_LAT_US, p95_lat_us, 0.0);
  }
  void add_p99_lat_us(double p99_lat_us) {
    fbb_.AddElement<double>(Kpi::VT_P99_LAT_US, p99_lat_us, 0.0);
  }
  void add_health_gap_frames(uint64_t health_gap_frames) {
    fbb_.AddElement<uint64_t>(Kpi::VT_HEALTH_GAP_FRAMES, health_gap_frames, 0);
  }
  explicit KpiBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Kpi> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Kpi>(end);
    return o;
  }
};

inline flatbuffers::Offset<Kpi> CreateKpi(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t updates = 0,
    uint64_t watchdog_trips = 0,
    uint64_t fallback_entries = 0,
    uint64_t limit_hits = 0,
    double iae = 0.0,
    double itae = 0.0,
    double tvu = 0.0,
    double p50_lat_us = 0.0,
    double p95_lat_us = 0.0,
    double p99_lat_us = 0.0,
    uint64_t health_gap_frames = 0) {
  KpiBuilder builder_(_fbb);
  builder_.add_health_gap_frames(health_gap_frames);
  builder_.add_p99_lat_us(p99_lat_us);
  builder_.add_p95_lat_us(p95_lat_us);
  builder_.add_p50_lat_us(p50_lat_us);
  builder_.add_tvu(tvu);
  builder_.add_itae(itae);
  builder_.add_iae(iae);
  builder_.add_limit_hits(limit_hits);
  builder_.add_fallback_entries(fallback_entries);
  builder_.add_watchdog_trips(watchdog_trips);
  builder_.add_updates(updates);
  return builder_.Finish();
}

struct TimeAnchor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TimeAnchorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EPOCH_MONO_NS = 4,
    VT_EPOCH_UTC_NS = 6
  };
  uint64_t epoch_mono_ns() const {
    return GetField<uint64_t>(VT_EPOCH_MONO_NS, 0);
  }
  uint64_t epoch_utc_ns() const {
    return GetField<uint64_t>(VT_EPOCH_UTC_NS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_EPOCH_MONO_NS, 8) &&
           VerifyField<uint64_t>(verifier, VT_EPOCH_UTC_NS, 8) &&
           verifier.EndTable();
  }
};

struct TimeAnchorBuilder {
  typedef TimeAnchor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_epoch_mono_ns(uint64_t epoch_mono_ns) {
    fbb_.AddElement<uint64_t>(TimeAnchor::VT_EPOCH_MONO_NS, epoch_mono_ns, 0);
  }
  void add_epoch_utc_ns(uint64_t epoch_utc_ns) {
    fbb_.AddElement<uint64_t>(TimeAnchor::VT_EPOCH_UTC_NS, epoch_utc_ns, 0);
  }
  explicit TimeAnchorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TimeAnchor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TimeAnchor>(end);
    return o;
  }
};

inline flatbuffers::Offset<TimeAnchor> CreateTimeAnchor(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t epoch_mono_ns = 0,
    uint64_t epoch_utc_ns = 0) {
  TimeAnchorBuilder builder_(_fbb);
  builder_.add_epoch_utc_ns(epoch_utc_ns);
  builder_.add_epoch_mono_ns(epoch_mono_ns);
  return builder_.Finish();
}

}  // namespace metrics
}  // namespace ictk

#endif  // FLATBUFFERS_GENERATED_ICTKMETRICS_ICTK_METRICS_H_
